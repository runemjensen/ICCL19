\documentclass{llncs}
\pagestyle{headings}
\usepackage{mathtools}
\usepackage{multirow, booktabs}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{graphicx} 
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage{cases}

\DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}
\newcommand{\var}{\mathit{var}}
\newcommand{\VAR}{\mathit{VAR}}
\newcommand{\Pos}{\mathit{Pos}}
\newcommand{\Neg}{\mathit{Neg}}
\newcommand{\trt}[1]{\texttt{#1}}
\newcommand{\mi}{\mathit}
\newcommand{\ve}{\mathbf}
\newcommand{\btablesize}{\begin{scriptsize}}
\newcommand{\etablesize}{\end{scriptsize}}
\newcommand{\set}[2]{\{\;{#1}\;|\;{#2}\;\}}
\newcommand{\lre}{\color{red}{\{}}

\newcounter{counterName}
\allowdisplaybreaks

\begin{document}

\title{A Decomposed Fourier-Motzkin Elimination Framework to Derive Capacity Models of Container Vessels}
\titlerunning{FME for Deriving Capacity Models}
\author{Mai L. Ajspur\inst{1} \and Rune M. Jensen\inst{1} \and and Kent H. Andersen\inst{2}}
\institute{The IT University of Copenhagen \and Aarhus University}

\maketitle

\begin{abstract}
Accurate capacity models expressing the trade-off between different container types that can be stowed on container vessels are required in core liner shipping functions such as uptake, capacity, and network management. Today, simple models based on volume, weight, and refrigerated container capacity are used for these tasks, which causes overestimations that hamper decision making.
Though previous work on stowage planning optimization in principle provide fine-grained linear Vessel Stowage Models (VSMs), they are too complex to be used in the mentioned functions. As an alternative, this paper contributes a novel framework based on Fourier-Motzkin elimination that automatically derives Vessel Capacity Models (VCMs) from VSMs by projecting unneeded variables. Our results show that the projected VCMs are reduced by an order of magnitude and can be solved 20-35 times faster than their corresponding VSMs with only a negligible loss in accuracy. Our framework is applicable to LP models in general, but are particularly effective on block-angular structured problems such as VSMs. We show similar results for a multi-commodity flow problem.
\keywords{Fourier-Motzkin Elimination \and Capacity Model \and Liner Shipping \and Projection.}
\end{abstract}

\section{Introduction}
Container shipping is a central element in the clockwork of global trade. A container liner shipping company operates a set of container vessels which sail on closed loop services with fixed schedules. These services connect major trade regions like Asia and Europe, and the liner shipping business is focused on utilizing the cargo capacity in their service network. Unused capacity constitute a loss that can be fatal in a market with a profit margin of just a few percent.  
To maximize utilization of capacity, it is central for a liner shipping company to be able to estimate the residual capacity of a container vessel. This is challenging in practice, since an empty slot may be impossible to utilize for a wide range of reasons including various stowage rules and seaworthiness requirements interact such that the free capacity of each container type and weight class is a complex function of the composition of cargo on board and the design of the vessel. Often it is only the stowage planning team that can determine the residual capacity of a vessel accurately and usually they must spent hours planning the vessel manually to do it. 

While stowage planners may be able to estimate free vessel capacity, the knowledge is primarily needed in higher functions such as: {\em uptake management} that control the sale of cargo bookings to fill the vessels with profitable cargo; {\em capacity management} that route cargo through the service network; and {\em network management} that makes changes to the service network. Decision makers in these functions seldom have stowage insight or time to consult the stowage team. They usually boil down the free capacity of a vessel to its nominal volume, weight, and reefer (refrigerated containers) capacity minus total volume, weight and reefer number of containers already on board. This simple three dimensional capacity model is inherently optimistic, since it ignores stowage complications. It has been shown that it can lead to revenue overestimates of more than 15\% \cite{AlbertosThesis}. This can cause sub-optimal decisions that significantly harm business. Previous work has contributed frameworks for automated stowage planning (e.g.,\cite{roach00,kimkang02,ambrosino04,pacino11}, and recently, linear stowage planning models were shown to scale to large container vessels (e.g., \cite{AlbertosThesis}). These latter Vessel Stowage Models (VSMs) embed an accurate capacity model, but since they include positioning information about the containers, they are too large for use as capacity models in higher functions, since these tasks often require several hundred capacity models to be solved simultaneously.

In this paper, we introduce a novel method to calculate a Vessel Capacity Model (VCM) automatically from a linear Vessel Stowage Model (VSM). Our basic idea is to derive the VCM by projecting out positioning variables from the VSM such that the VCM only expresses the relationship between variables that represent the total amount of each possible container type. Despite a theoretical double-exponential complexity, Fourier-Motzkin Elimination (FME) has been applied successfully for this purpose in previous work including constraint programming (e.g., \cite{lassez90}) and software verification (e.g., \cite{benoy05}). Our main contribution is to improve the state-of-the-art of these FME-based projection frameworks (e.g., \cite{simon05,lukatskii08,shapot12}). In particular, we introduce a novel decomposition method that takes advantage of block-angular structured models such as VSMs to significantly speed-up the projection of variables in these models. Additionally, our removal of redundant constraints is parallellized, and the framework includes preprocessing of the constraint system including removal of less strict inequalities.

Our experimental evaluation of computing VCMs with this method shows that the number of constraints and non-zeros in the resulting VCMs typically are reduced by an order of magnitude compared to their corresponding VSMs. Moreover, the decomposition method reduces the size of the intermediary models produced by FME, causing less time to be needed for removing redundant constraints, which again speeds up the projection process significantly. In addition, for the models that include hydrostatic constraints, the resulting VCMs can be solved 20-35 times faster than their VSMs with only a negligible loss in accuracy. Although it can take several hours to derive a capacity model due to the clean-up of redundant constraints, this only has to be done one time for a vessel class. In this way, the approach is suitable for computing capacity models. Moreover, since they are linear and much faster to solve than their corresponding stowage models, they also can be integrated in decision support systems used to optimise these higher functions in liner shipping. Multi-commodity flow problems also have a block-angular structure and we found a speed-up and a reduction in final size similar to the ones seen for VCMs.

This paper is organized as follows. Section~\ref{sec:model} briefly presents the VSMs that are projected, and Section~\ref{sec:notation} introduces the required definitions and notation for our FME framework. Then Section~\ref{sec:method} outlines the methods used in our FME framework including how block-angular problems are decomposed. Our experimental results then follows in Section~\ref{sec:results}. Section~\ref{sec:relatedwork} present related work, before Section~\ref{sec:conclusion} concludes.


\section{Vessel Stowage Model}\label{sec:model}
A Vessel Stowage Model (VSM) is a set of linear inequalities over continuous decision variables (i.e., a polyhedron) defining feasible stowage conditions of a container vessel. The VSMs in this paper are based on previous work on stowage planning optimization (e.g., \cite{roach00,kimkang02,ambrosino04,pacino11}). 

Consider the container vessel shown in Figure~\ref{fig:vessel}. Each \emph{cell} on the vessel can hold two 20' containers or one 40'. Some cells have power plugs, allowing refrigerated containers (\emph{reefers}) to be stowed. Each container stack rests on sockets with maximum weight limits. Stacks are arranged longitudinal in \emph{bays} that can be further subdivided into \emph{locations}. The volume capacity of a vessel is measured in Twenty-foot Equivalent Units (TEUs) and can be more than 20K. Stowage conditions must satisfy a large number of interacting requirements. The vessel must be seaworthy with proper transversal stability and stress forces within limits. To that end, it can fill large water ballast tanks to achieve stability. The container stacks must by physically possible (e.g., 20' containers cannot be stowed on top of 40' containers) and there are separation rules for dangerous cargo. For an in-depth coverage of container vessel stowage, we refer the reader to a recent book on the topic \cite{JPAV18}.     

\begin{figure}[b!]
	\centering
		\includegraphics{figures/vessel4.pdf}
	\caption{Vessel structure and reference points.}
	\label{fig:vessel}
\end{figure}

The VSM that we investigate is based on industrial data from a large carrier that define volume, weight, and reefer capacities for each location of the vessel. Moreover, it gives positive and negative stress force limits (i.e., shear force and bending moment) for a set of \emph{frame positions}. It also contains a Bonjean table that for different drafts gives the submerged area of a cross-section of the vessel for a number of \emph{station positions} (see Figure~\ref{fig:vessel}). 

The VSM considers 20' and 40' containers in three weight classes (6, 21 and 27 tons) and a container is either reefer and non-reefer. This gives total of 24 container types $T$. For each container type $\tau \in T$ and location $l$ on the vessel, there is a decision variable $x_{l,\tau} \in \mathbb{R}$ defining the number of containers of this type in the location. Due to the large number of containers, we ignore the integrality of these variables as in \cite{pacino11}. The VSM includes volume, weight and reefer capacity constraints for each location. To simplify the representation of hydrostatic constraints, we divide the vessel into \emph{sections} as shown in Figure~\ref{fig:vessel}. The VSM has constraints that restrict shear forces and bending moments to be within limits between sections. To this end it has constraints defining the resulting force on each section using a linear approximation of its buoyancy and weight. The weight of ballast water in each section $s$ is given by a decision variable $t_s \in \mathbb{R}$. The hydrostatic modelling approach of the VSM is detailed in \cite{ICCL18}. Due to space limitations, we do not include a formal definition of the VSM. It can be found in \cite{mytechrep}. 

A Vessel Capacity Model (VCM) is derived from a VSM by adding auxiliary variables to the VSM equal to the total of each container type and projecting all other variables out using FME. In this way the container positioning information is abstracted away. While our experiments are carried out on the VSM from \cite{mytechrep}, we will for the sake of explaining our FME framework consider the toy version shown below exposing its block-angular structure. 
\begin{numcases}{S_\texttt{g}:}
x_\tau = \sum_{i\in S} x_{i,\tau} & $\forall{\tau \in T}$\label{eq:sumT}\\
\sum_{i\in S}\sum_{\tau\in T}W_\tau x_{i,\tau} \leq D\label{eq:sumW}
\end{numcases}
\begin{numcases}{S_i\text{ for all }i\in S:} 
                                                          \smashoperator[lr]{\sum_{\tau \in T^\trt{20}}} x_{i,\tau} \leq C_i^\trt{20}                         
                                                                                                                    & $\smashoperator[lr]{\sum_{\tau \in T^\trt{20}}} W_\tau x_{i,\tau} \leq C_i^\trt{W20}$ \label{eq:cap20}\\
                                                          \;\smashoperator[lr]{\sum_{\;\tau \in T\setminus T^\trt{20}}} 2 x_{i,\tau} \leq C_i^\trt{40}
                                                                                                                    & $\smashoperator[lr]{\sum_{\tau \in T^\trt{20}}}0.5 W_\tau x_{i,\tau} + \smashoperator[lr]{\sum_{\tau \in T\setminus \in T^\trt{20}}} W_\tau  x_{i,\tau} \leq C_i^\trt{W40}$ \label{eq:cap40}\\ 
                                                                                       \smashoperator[r]{\sum_{\tau \in T^\trt{R}}} x_{i,\tau} \leq C_i^\trt{RS}
                                                                                                                    & $\smashoperator[lr]{\sum_{\tau \in T^\trt{20}}} x_{i,\tau} + 2\smashoperator[lr]{\sum_{\tau \in T\setminus T^\trt{20}}} x_{i,\tau} \leq C_i^\trt{TEU}$ \label{eq:capReefer} 
                                                                                                                   
\end{numcases}
In this toy VSM, the decision variable $x_{i,\tau} \in \mathbb{R}$ is the number containers in section $i$ of type $\tau$. There are two global constraints (\ref{eq:sumT}) and (\ref{eq:sumW}). The first defines the auxiliary variables $x_\tau$ that totals the container types (i.e., the only variables left in the VCM). The second is an assumed maximum weight $D$ of the cargo, where $W_\tau$ is the weight of type $\tau$. The following three constraints are defined for each section $i \in S$ and forms a block $S_i$ in the block-angular structure. The first and second (\ref{eq:cap20} and \ref{eq:cap40}) are volume ($C_i^\trt{20}$ and $C_i^\trt{40}$) and weight capacity ($C_i^\trt{W20}$ and $C_i^\trt{W20}$) constraints of 20' and 40' containers, respectively. Notice that the weight limits of 40' containers includes half of the weight of 20' containers due to the arrangement of sockets. The last constraint (\ref{eq:capReefer})  represents reefer ($C_i^\trt{RS}$) and total TEU capacity ($C_i^\trt{TEU}$). Notice that a 40' container counts two TEU.    

\section{Definitions and notation} \label{sec:notation}
A constraint system $S$ is a set of equalities and inequalities over the same set of variables, $\VAR(S)=\{x_1,\ldots, x_n\}$. Each constraint $c$ is either an equality, written $a_1x_1 + \ldots +a_nx_n = b$, or an inequality, written $a'_1x_1 + \ldots +a'_nx_n\leq b'$. Alternatively, we use dot-product notation for the left-hand-side, i.e. $\ve{a}\cdot \ve{x}$. 
We let $\var(c)$ denote the variables whose coefficient in $c$ is nonzero and say that $c$ \emph{uses} $x$ if $x\in \var(c)$. 
The set of points in $\mathbb{R}^{|\VAR(S)|}$ that satisfies all constraints in $S$ is called the \emph{feasible area} of $S$. A constraint $c\in S$ is \emph{redundant} iff it does not influence the feasible area for $S$, otherwise it is called \emph{non-redundant}.  

For some variables $Y\subseteq \VAR(S)$, we are not interested in their values in a feasible point - we just want to know that a satisfying value exists. This property is captured by the \emph{projection of $S$ w.r.t. $Y$}, which is the largest set consisting of values for $\VAR(S)\setminus Y$ that can be extended with values for $Y$ such that all constraints in $S$ are satisfied. 
%
The projection of a constraint system is a uniquely determined subset of $\mathbb{R}^{|\VAR(S)\setminus Y|}$, but also the feasible region of another system $S'$ (see e.g. \cite{ziegler95}). We are mostly interested in the latter, since it is the relationship between the values in the projection that is relevant to us, and we allow ourselves to write that ``$S'$ is the projection of $S$ w.r.t. $Y$'' if the feasible area of $S'$ equals the projection of $S$, though such a system is not uniquely determined.
We note, that since we are dealing with subsets of multi-dimensional Euclidian spaces, the dimension and the order of the variables are important. However, in order to simplify the presentation, we do not explicitly specify these for every considered projection/constraint system $S'$. A more stringent exposition keeping track of the variable sets and ordering can be found in \cite{mytechrep}.


\section{FME-based projection framework} \label{sec:method}
Our FME-based projection framework can be used for massive variable elimination in any linear inequality system but has been designed to take advantage of block-angular structures often found in real-world models including the VSM. The methods for projecting a constraint system are described in Section~\ref{sec:projMethod}, while the decomposition used on block-angular structured problems is  described in Section~\ref{sec:decomp}.

\subsection{Projection procedure}\label{sec:projMethod}
The projection procedure starts with a preprocessing of the constraint system.
Then we use the equalities in the reduced system to isolate variables from $Y$ and substitute in the rest of the system, i.e. \emph{Gauss-elimination}.  
Subsequently, we successively eliminate one variable from $Y$ using Fourier-Motzkin elimination and remove redundant inequalities. At the top-level, the pseudocode for our projection method is described in Algorithm~\ref{alg:FMEF}. 
\setlength{\floatsep}{10pt} %standard minimum er vist 16
\setlength{\textfloatsep}{14pt} %standard minimum er vist 16
\begin{algorithm}[b!]
\caption{Projection based on Fourier-Motzkin elimination} 
\label{alg:FMEF}
\begin{algorithmic}
\Function{Project}{System $S$, Variables $Y$}
	\State $(S,Y)\gets \Call{Preprocess}{S,Y}$
	\State $(S,Y)\gets\Call{Gauss-Elim}{S,Y}$
	\While{$Y\neq\emptyset$}
		\State $(S, Y, New )\gets\Call{FME-SingleVar}{S,Y}$
		\State $S\gets\Call{RemoveRedundancy}{S,New}$
	\EndWhile
	\State \Return $S$
\EndFunction
\end{algorithmic}
\end{algorithm}
Each sub-procedure in this algorithm is detailed further below. 

{\sc Preprocess}$(S,Y)$. We reduce $S$ by removing easily identifiable redundant constraints and assign necessary bounds and values to variables using well-known LP preprocessing steps (e.g., \cite{andersen95}). The steps are implemented with special care of equalities and working with the assumption that the system is feasible (details can be found in \cite{mytechrep}).

{\sc Gauss-Elim}$(S,Y)$. An equality $e$ can be used to isolate a variable $ x\in Y$ which can then be substituted in all other constraints in $S$ (a Gauss-elimination). This eliminates $x$ from the system and does not cause the same combinatorial explosion of inequalities as FME may do (e.g., \cite{duffin74,simon05}). We Gauss-eliminate as many variables in $Y$ as possible. To avoid density, when the system $S$ contains several equalities, we first choose the variable $x$ (used in any equality) that is used the fewest times in total in $S$. We then choose the equation $e$ among those using $x$ that uses the fewest variables, and do Gauss-elimination of $x$ using $e$. This is then repeated until there are no more equalities using variables from $Y$.

{\sc FME-SingleVar}$(S,Y)$. Fourier-Motzkin Elimination (FME) is a classical algorithm for producing the projection of a set of variables from an inequality system, i.e. a constraint system with no equalities. The method successively eliminates one variable $x\in Y$ until all required variables have been eliminated. To eliminate $x\in Y$, the constraints in $S$ are first divided into three sets, $\Pos_S(x)$, $\Neg_S(x)$, and $\mi{Zero}_S(x)$ depending on the sign of the coefficient of $x$. Each equality is treated as two inequalities, and bounds are treated as any other inequalities. 
A new system $S'$ is then created, which is the projection of $S$ w.r.t. $\{x\}$. It consists of $\mi{Zero}_S(x)$, together with one inequality, $i_{p,n,x}$, for each pair $(p,n)\in \Pos_S(x)\times \Neg_S(x)$. $i_{p,n,x}$ is the addition of positive multiples of $p:\ve{a}\cdot\ve{x} \leq b$ and $n:\ve{a}'\cdot\ve{x} \leq b'$ such that the coefficient of $x$ in the resulting inequality is $0$, i.e.
\[
i_{p,n,x}: -a'_x\cdot \ve{a}\cdot\ve{x} + a_x\cdot \ve{a}'\cdot\ve{x} \leq -a'_x\cdot b + a_x\cdot b'.
\]
The order in which variables are eliminated naturally influences the size of the intermediary inequality systems. We have chosen to use the greedy heuristic {that minimizes the number of new inequalities in the immediately next system \cite{duffin74}}, which is a commonly used heuristic. It is easily calculated from the current system as the variable $x\in Y$ that minimizes $|\Pos_S(x)||\Neg_S(x)| - |\Pos_S(x)|-|\Neg_S(x)|$.  In the worst case scenario, %where $|\Pos_S(x)| = |\Neg_S(x)| = \frac{|S|}{2}$ for all $x\in Y$, 
the number of inequalities in the created system $S'$ is $\frac{1}{4}|S|^2$, which implies that (both time and space) complexity is double-exponential. For a large, dense system, the growth will be substantial, which prohibits it from use for practical purposes \emph{if} the added inequalities are non-redundant or the non-redundant inequalities are not removed ({see e.g. \cite{lukatskii08}}). It should, however, also be emphasized that not all inequalities in the succeeding system are necessarily non-redundant; in fact, the number of non-redundant inequalities will at most grow exponentially \cite{monniaux10}.

{\sc RemoveRedundancy}$(S,\mathit{New})$. To detect redundancy, we examine each inequality $c: \ve{a}\cdot \ve{x}\leq b$ in turn and remove it from the system if $\max \ve{a}\cdot \ve{x}$ subject to $S\setminus\{c\}$ is less than or equal to $b$. The property can be checked using an LP solver. Only inequalities are examined, since we want to keep the equalities for use in Gauss-elimination. Not all inequalities have to be examined, though. When removing redundancy after projecting $x$ from $S$, we do not need to check inequalities in $\mi{Zero}_S(x)$; if they were non-redundant before the elimination, they will be non-redundant after. For large systems, checking all constraints for redundancy is time-consuming. We have therefore implemented a method for redundancy removal that uses several threads in parallel. Each thread checks one inequality at a time, while a manager takes care of the communication and keeps track of the found redundant inequalities. 
Several of the constants in the data used for our vessel models are results of various approximations and hence the boundary of the feasible area is not exact. Coarsening the boundary is therefore permissible, and we also remove inequalities that are \emph{``almost redundant''}. An inequality $c: \ve{a}\cdot\ve{x}\leq b$ is almost redundant if $\max \ve{a}\cdot\ve{x}$ subject to $S\setminus\{c\}$ is less or equal to $b + \epsilon\cdot |b|$ for a small $\epsilon$. Methods for coarsening the boundary of the feasible area are also used in \cite{lukatskii08,shapot12}.

\subsection{Decomposing a block-angular system}\label{sec:decomp}
Looking at the simplified VSM from Section~\ref{sec:model}, it is clear that this has a natural (primal) block-angular structure (\cite{williams}): The set of capacity constraints for section $i\in S$ constitutes a local system, $S_i$ whose constraints only use variables that are not used in $S_{i'}$ for a different section $i'$. The remaining constraints make up the global subsystem, $S_\texttt{g}$, where the constraints also use variables from several of the local subsystems. This structure is illustrated in Figure~\ref{fig:decomp2}(a) for a VSM with four sections. 

To derive the VCM of this VSM, we want to eliminate all variables but $\set{x^\tau}{\tau\in T}$, the variables counting the number of containers of each type. However, when a variable $x_{i,\tau}$ is eliminated, the inequalities constructed by FME uses variables from all subsystems, since $x_{i,\tau}$ is used in the global constraints. Continuing FME, this result in an increasing number of global and more dense constraints, which again makes FME perform worse. 
To avoid the immediate ``mix'' of local subsystems, we will exploit the system's block structure and define and use auxiliary variables to ensure that we can project the local subsystems separately without producing global constraints, before we combine the projected subsystems and eliminate the auxiliary variables. 

For the considered VSM, we first define a variable to hold the weight of cargo in each section $i$, $w_i$. We also define the variable $x'_{i,\tau} = x_{i,\tau}$, although this is only a renaming of the variables at first glance. We add the defining constraints to the relevant local system, and redefine the global constraints in terms of the new variables. 
That is, the $i$'th local subsystem is now $S_i^0 = S_i \cup \{w_i = \sum_{\tau\in T} W_\tau x_{i,\tau}\} \cup \bigcup_{\tau\in T}\{x'_{i,\tau} = x_{i,\tau}\}$, while the new system of global constraints is $S_g^0 = \cup_{\tau\in T}\{x^\tau = \sum_{i\in S} x'_{i,\tau}\} \cup \{w_1 + w_2 + w_3 + w_4 \leq D\}$. 

Notice, that due to the new auxiliary variables, for a given $i\in S$, none of the variables $x_{i,\tau}$ is used in any constraints outside of $S^0_i$. Therefore, to project $\set{x_{i,\tau}}{\tau\in T}$ from the whole system ($S^0_g\cup_{i'\in S}S^0_{i'}$) we can just eliminate $\set{x_{i,\tau}}{\tau\in T}$ from $S_i^0$. In the end, when all subsystems $S^0_i$ have been projected, we can join these projections together with $S^0_\trt{g}$ and eliminate the remaining variables, $\set{x'_{i,\tau}}{\tau\in T, i\in S}\cup\set{w_i}{i\in S}$, from the resulting system.

More formally, for a block-angular structured system with local sybsystems $S_1,\ldots, S_k$ (using the variables $X_1,\ldots, X_k$) and global subsystem $S_\texttt{g}$, to separate and remove local variables from the global constraints, we do as follows for all subsystems $S_i$ (detailed pseudocode and correctness proofs can be found in \cite{mytechrep}). 
\begin{itemize}\itemsep0em
\item For each global constraint $c$ using variables in $S_i$, we define an auxiliary variable $z^0_{c,i}$ that equals the variables in $S_i$'s contribution to $c$. We add the equality defining $z^0_{c,i}$ to $S_i$, and we substitute it in $c$. 
We name the thusly produced subsystem $S_i^0$. 
\item Then, we project $S_i^0$ w.r.t. all variables from $Y\cap X_i$, where $X_i=\mi{var}(S_i)$, resulting in the system $S'^{\,0}_i$. We do keep the auxiliary $z^0$-variables. 
Because of these auxiliary variables this only produces inequalities with variables not present in other subsystems $S_j$. 
\end{itemize}
After projecting each $S_i^0$ we can then combine the results with the rephrased, global constraints, $S_\trt{g}^0$, to create the system $\mathcal{S} \overset{\text{def.}}{=}
\mathcal{S} = S^0_\trt{g} \cup S'^{\,0}_1\cup \ldots \cup S'^{\,0}_k$.
We can then eliminate from $\mathcal{S}$ all the auxiliary $z^0$-variables, $Z^0$, plus any remaining variables in $Y$. 

Comparing $\mathfrak{S} \overset{\text{def.}}{=} S_1^0\cup\ldots\cup S_k^0\cup S_\trt{g}^0$ with the original system $S$, all we have done is defining auxiliary variables and substituted them in the system. Thus, eliminating $Y$ from $S$ is equivalent to eliminating $Y \cup Z^0$ from $\mathfrak{S}$. 
%
When eliminating $Y\cup Z^0$ from $\mathfrak{S}$, we can choose to first eliminate $X_1\cap Y$, then $X_2\cap Y$ up to $X_k\cap Y$, and finally $Z^0\cup Y\setminus(X_1\cup \ldots\cup X_k)$. 
Any variable in $X_1\cap Y$ has a zero-coefficient in all constraints outside $S^0_1$, so $\mathfrak{S}\setminus S^0_1$ will not be changed by FME when $X_1\cap Y$ is eliminated. It can therefore be put aside until that projection is done. 
Likewise, when eliminating $X_i\cap Y$, neither $S_{i+1}^0\cup \ldots \cup S_k^0\cup S_\trt{g}^0$ nor the already projected systems contain any variables from $X_i\cap Y$ and can hence be put aside until the variables in $Z^0\cup Y\setminus(X_1\cup \ldots\cup X_k)$ are eliminated. Thus, the following holds. 
%
\begin{proposition}
The projection of $S$ w.r.t. $Y$ defines the same feasible area as 
the projection of $\mathcal{S}$ w.r.t. $Z^0 \cup Y\setminus (X_1\cup \ldots \cup X_k)$. 
\end{proposition}
%
$\mathcal{S}$ has by construction a block-angular structure and instead of eliminating $Z^0\cup Y\setminus(X_1\cup\ldots\cup X_k)$ immediately, if necessary, we can use the same approach as above to postpone ``mixing'' blocks.
To do so, we collect all subsystems into $k_1$ small groups and do the following for each group $i$. 
\begin{itemize}\itemsep0em
\item We join the systems in the group into a new system, $S^1_i$. For each (rephrased) global inequality $c$ using variables occurring in $S^1_i$, we then define a variable, $z^1_{c,i}$, that equals $S^1_i$'s contribution to $c$. We add the defining equality to $S^1_i$ and rephrase $c$ using $z^1_{c,i}$.
\item Then we project the resulting system, $S^1_i$, w.r.t. the previous, auxiliary $z^0$-variables, while we keep the newly created $z^1$-variables.
\end{itemize} 
Subsequently we can then join the projected $S^1$-systems with $S_\trt{g}^1$, and finally project the last auxiliary variables. Alternatively, we can repeat the steps above until the final projection can be done. 

When we decompose a system as described above, we effectively create a tree structure of subsystem paired with a set of variables to be eliminated. An inequality system can then be projected by recursively projecting its children. See Figure~\ref{fig:decomp2} and the example further below.
\begin{figure}[t!]
	\centering
		\includegraphics[scale=0.9]{figures/Example5.pdf}
	\caption{(a) A block-angular structured system. (b) Projection using tree-structure.}
	\label{fig:decomp2}
\end{figure}
The intuition why this works is as before; projecting all $Y$ and $Z$-variables from the union of all the (unprojected) subsystems in the nodes of the tree corresponds to projecting the $Y$ variables from $S$, and because we can choose the elimination order of the variables, we only need to project the subsystems in the tree in the correct order (a rigorous proof can be found in \cite{mytechrep}).

\begin{proposition}
The projection of the system associated with the root of the tree constructed from $S$ and $Y$ w.r.t. the $Y$- and $Z$-variables as described corresponds to projecting $S$ w.r.t. $Y$.
\end{proposition}

Consider again the VSM that was decomposed into the subsystems $S^0_\trt{g}$ and $S^0_i$ for $i\in S$. Instead of projecting these subsystems as described in the start of this section, we can insert an additional level in the decomposition, if for examples the constraints in $S^0_\texttt{g}$ uses too many variables. 
Assume for instance that $S=\{1,2,3,4\}$. Then we can group the four subsystems into two groups, $\{S^0_1, S^0_2\}$ and $\{S^0_3, S^0_4\}$, and for each global constraint, we define a variable stating each new group's contribution to the global constraint. For example, we define a variable $w_{\{1,2\}}$ that is the weight of the containers in section 1 and 2. The defining variables are added as a new subsystem, and the global constraints are rephrased. That is, we construct the following subsystems.
\vspace{-1mm}
\footnotesize{
\[
\begin{gathered}
S_\trt{g}^1 :\{ x^\tau = x'_{\{1,2\}} + x'_{\{3,4\}},\: w_{\{1,2\}} + w_{\{3,4\}} \leq D \},\\   
S^1_1				:\{ x'_{\{1,2\}} = x'_{1} + x'_{2},\: w_{\{1,2\}} = w_{1} + w_{2}\},\:
S^1_2				:\{ x'_{\{3,4\}} = x'_{3} + x'_{4},\: w_{\{3,4\}} = w_{3} + w_{4}\}. 
\end{gathered}
\]}
\normalsize{These systems compose a tree structure, whose root is projected recursively as shown in Figure~\ref{fig:decomp2}(b) to obtain the projection of the original VSM.}

Using our previously described projection method, we obtain the projection of $S$ w.r.t. $Y$ by calling \Call{ProjectNode}{root of $T$}, where $T$ is the tree structure constructed from $S$ and $Y$, and \Call{ProjectNode}{} is described in Algorithm~\ref{alg:decomp}.
\begin{algorithm}[b!]
\caption{{Projecting a block-structured system via decomposition.}}
\label{alg:decomp}
\begin{algorithmic}
\Function{ProjectNode}{Node $n$} 
	\State $(S,Y)\gets$ the system and variable set associated with $n$
	\If{$n$ is a leaf}
		\State \Return \Call{Project}{$S$, $Y$}\Comment Algorithm~\ref{alg:FMEF}
	\Else
		\ForAll{children $m$ of $n$}
			\State $S \gets S\cup \Call{ProjectNode}{m}$ 
		\EndFor
		\State \Return $\Call{Project}{S, Y}$ \Comment Algorithm~\ref{alg:FMEF}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
Using the described decomposition, it is of course also possible to project nested block structured problems, i.e. systems that on the top-level can be divided into a global part and a number of local parts that in themselves can be further divided into local parts and a global part, and so on. Other block structured problems such as staircase problems can also be decomposed into a tree structure and projected using the described approach. 

Further, when the system $S$ is decomposed into subsystems in a tree structure, the projection itself can be parallelized by maintaining a queue of not yet projected subsystems whose children have all been projected; this queue thus initially contains all leafs. 
  
\section{Results}\label{sec:results}
We have constructed a number of different VSMs for a specific vessel, where the weight and hydrostatics are taken into account to various degrees. The first VSM has no limit on the total displacement or any hydrostatic constraints, the second VSM does not model any hydrostatic constraints, and the subsequent VSMs (refered to as complex VSMs) consider the stress force  constraints at 2, 4, 6 and 8 measure points, respectively. 
Each VSM has been transformed into its corresponding VCM by eliminating all variables except the $x_\tau$ variables. Projections have been done in two different ways, \emph{decomposed} and \emph{flat}. For the decomposed projections, a tree structure has been used as described previously, while the flat projections do not use any decomposition at all. CPU time is measured in both number of iterations and \emph{ticks} calculated by the CPLEX Interactive Optimizer version 12.5.0.0. Our FME-based projection framework has been implemented in Java. The experiments were carried out on a computer with an {Intel\textsuperscript{\textregistered} Xeon\textsuperscript{\textregistered} CPU with 8 cores and 32GB RAM.}

Table~\ref{tab:projections} shows the size reductions of the VCMs. It summarizes the size of the VSMs and the VCMs that are the result of the projection using decomposition. These sizes are given in terms of the number of inequalities (ineq), equalities (eq), variables (var), non-zero entries (nzs) and density (dens). The size of the VSMs are given both as they appear as input to our algorithm, but also after it has been preprocessed by CPLEX. For comparison, the table includes a "Simple VCM" corresponding to the maximum volume, weight, and reefer capacity models used in liner shipping today.   
\begin{table}[b!]
\caption{The size of the VSMs and corresponding VCMs.}
\label{tab:projections}
\centering
\btablesize
\begin{tabular}{l|*{2}{*{3}{r@{\:\;}}r|}*{3}{r@{\:\;}}r}
$\multirow{2}{*}{}$&\multicolumn{4}{c|}{VSM}&\multicolumn{4}{c|}{VSM, presolved}& \multicolumn{4}{c}{VCM}\\
							&ineq (eq)&var &nzs & dens  &ineq &var	&nzs	&dens&ineq &var &nzs &dens\\
\hline
{No weights}	&774 (12)	&1142&6662&8.61		&554	&657	&2784	&5.03&	20 &12	& 155&7.75\\   %554/20 = 27,7, 657/12 = 54,74,  2785/155 = 17,97
{No hydro.} 	&806 (43)	&1173&7854&9.74		&555	&657	&3441	&6.20&	18 &12	& 144&8.00 \\  %555/18 = 20,8, same							3441/144 = 23,89
{2 parts} 		&810 (43)	&1173&7860&9.70		&556	&661	&3447	&6.20&	96 &12	&1113&11.59\\  %556/96 = 5,8, 661/12 = 55				3447/1113 = 3,09
{4 parts} 		&824 (49)	&1179&7886&9.57		&564	&671	&3471	&6.15&	64 &12	& 731&11.42\\  %564/64 = 8,8										3471/731 = 4,74
{6 parts} 		&838 (55)	&1185&7916&9.44		&570	&679	&3496	&6.13&	80 &12	& 888&11.10\\  %570/80 = 7,1										3496/888 = 3,94
{8 parts} 		&852 (61)	&1191&7950&9.33		&576	&685	&3522	&6.11&	52 &12	& 582&11.19\\  %576/52 = 11,1 685/12 = 57.1			3522/582 = 6,05
\bottomrule
Simple VCM 		& 3\phantom{ (55)}&12 &\phantom{12}36&12.00&3&9&\phantom{12}24&\multicolumn{1}{l}{8.00}\\
\end{tabular}
\etablesize
\end{table}
Since we project all but 12 variables, this naturally gives a large reduction in the number of variables, more precisely 54-57 times fewer than even the presolved VSMs. However, the VCMs also have 5.8-11.8 times fewer inequalities than the presolved VSMs (for complex VSMs) while they two others have 20.8-27.7 times fewer constraints. The VCMs also have fewer non-zero entries (3-6 times fewer for complex VSMs, and otherwise 18-24). The results reveal no apparent relationship between the size of the VSM and the size of its VCM.

Regarding decomposition impact, Table~\ref{tab:time} shows the time taken for the algorithm to do the projection, both decomposed and flat. For most VSMs, the flat projection timed out (TO) after 18 hours, in which case the variables left to be projected are given. Figure~\ref{fig:8parts}(a) shows the progression of the number of inequalities and variables, respectively, as a function of time when the algorithm runs on the decomposed 8 part model. These numbers are the sum of all the inequalities and variables, respectively, in all the projected or unprojected subsystems in the decomposition at a given time. Likewise, Figure~\ref{fig:8parts}(b) shows the progression for the flat projection of the same model; this figure includes the number of inequalities for the decomposed projection for comparison. Each graph shows the number of inequalities and variables after each step outlines in Section~\ref{sec:projMethod}.    
\begin{table}[t!]
\caption{Projections time.}
\label{tab:time}
\centering
\btablesize
\begin{tabular}{l|r@{\hspace{0em}}rc|rc}
&\multicolumn{3}{c|}{Decomposed}&\multicolumn{2}{c}{Flat}\\
&\multicolumn{2}{c}{time}& vars left &\multicolumn{1}{c}{time}&vars left\\
\hline
{No weights}& &24.5m&-&2.5m&-\\
{No hydro.}& &14.5m&-&1.8m&-\\
{2 parts} &7h&18m &-&(TO) 32h& 551\\
{4 parts} &8h&4m &-&(TO) 61h & 557\\
{6 parts} &3h&7m &-&(TO) 18h & 577\\
{8 parts} &3h&19m &-&(TO) 65h& 566\\
\end{tabular}
\etablesize
\end{table}
The results in Table~\ref{tab:time} shows that the decomposition has a substantial impact on the success of the projection of the complex VSMs. However, the two non-complex VSMs are solved faster using a flat projection. This is probably because they are sparse without the hydrostatic constraints. 
\begin{figure}[b!]
	\centering
		\includegraphics{figures/newDecompFig.pdf}
	\caption{The inequalities growth and variable decrease for the 8 part-model (a) with decomposition and (b) flat.}
	\label{fig:8parts}
\end{figure} \\
\indent When considering each subsystem in a decomposition as a system in itself, in general, the number of inequalities after each call to \Call{FME-SingleVar}{} in Algorithm~\ref{alg:FMEF} grows to begin with, as does the number of inequalities before this call. This continues until there are a few variables left, where both these numbers decrease. For the decomposed algorithm, though the number of inequalities grow after each FME-step, most of them are redundant or almost redundant. The same does not hold for the flat projection of the complex VSMs (at least not for the FME-steps that are completed within the time limit). On the contrary, many of the produced inequalities are non-redundant, increasing the likelyhood that even more inequalities will be produced in the next elimination and that the redundancy removal will take longer time. We also note that the runtime, even for the decomposed projections, are not exactly small, and the main part of the execution time is spend doing redundancy removal. However, as mentioned in the introduction, these calculations only need to be done once per vessel class. \\
\indent As a use-case example, the VSMs and their projected VCMs have been optimized for revenue. Each transported container yields a fixed revenue based on its type. Table~\ref{tab:usingProjections} shows the number of iterations (iter), the deterministic time in ticks (time) and the optimal objective value (obj) in $10^6 \$$. It likewise shows how many times faster, the projections are w.r.t. iterations and deterministic time, as well as the difference in objective value in percentage. For comparison, the number of iterations, deterministic time and objective value is shown for the simple VCM, too.
\begin{table}[tb]
\caption{Iterations, time and objective values for the VSMs and VCMs.}
\label{tab:usingProjections}
\centering
\btablesize
\begin{tabular}{l|r@{\:\;}r@{\:\;}r|r@{\:\;}r@{\:\:\:}r|rrr}
&\multicolumn{3}{c|}{VCM}&\multicolumn{3}{c|}{VSM}&\multicolumn{3}{c}{Difference}\\
					&iter&time  &obj 	 &iter  &time  &obj	&iter 			 &time					&obj\\ 
\hline
No weights&	11 & 0.05 & 8.63 &	363 & 2.64 &8.08&$\times$33.0&$\:\times$52.8&$\:$6.8$\%$\\
No hydro. &  9 & 0.04 & 7.87 &	188 & 5.48 &6.22&$\times$20.9&$\:\times$137 &$\:$26.5$\%$\\
2 parts		& 14 & 0.29 & 6.09 &	251 & 5.88 &6.07&$\times$17.9&$\:\times$20.3&$\:$0.196$\%$\\
4 parts 	& 13 & 0.18 & 6.17 &  228 & 4.95 &6.16&$\times$17.5&$\:\times$27.5&$\:$0.153$\%$\\
6 parts 	&  9 & 0.20 & 6.17 &  227 & 5.02 &6.18&$\times$25.2&$\:\times$25.1&$\:$0.202$\%$\\
8 parts 	& 12 & 0.14 & 6.21 &  233 & 4.79 &6.18&$\times$9.4&$\:\times$34.2&$\:$0.490$\%$\\
\bottomrule
Simple VCM&  4 & 0.02 &10.7\phantom{0}\\
\end{tabular}
\etablesize
\end{table}
As can be seen from the numbers in Table~\ref{tab:usingProjections}, in general, VCMs are much faster to solve than their corresponding VSMs. More specifically there are between approx. 17 and 33 times fewer iterations and 20-137 times fewer ticks, which corresponds to a difference between 94\% and 97\% of the number of iterations, and 96\% and 99.5\% CPLEX ticks, respectively. Meanwhile the difference in objective value is only modest; for the models including hydrostatic constraints, the difference is at most 0.5 \%, while the other two models have a difference of 6.8 and 26.5 \%, respectively. 
When comparing to the simple model, we see that this model of course is even faster (between 41-97 times (iterations) and 132-294 (ticks)), but the difference in objective is also between 72\% and 76\% for the last 5 models. Hence, our results confirm the experiments by Delgado \cite{AlbertosThesis} showing a substantial revenue overestimation of capacity models used in liner shipping today. \\
\indent Beside the VSM, we have studied another block-angular structured system, namely one describing a multi-commodity flow problem.  
In short, this problem considers a graph on which a number of commodities can flow on the edges. Each edge has a capacity (upper bound) for each commodity as well as a common total capacity. Demands and supply are modelled as variables, and we want to examine the relationship between the supply and demand of the commodities without having to care about how the items flow in the internal nodes. This can be done by eliminating all other variables than the ones denoting the demands and supply of each commodity. We have generated the flow graph shown in Figure~\ref{fig:multiflow} with inspiration from the Chen.DSP collection \cite{JLFP93}. 
\begin{figure}[b!]
	\centering
		\includegraphics[scale=0.5]{figures/multiflow2.pdf}
	\caption{A ``layered''  graph for a multi-commodity flow problem.}
	\label{fig:multiflow}
\end{figure}
It consists of seven ``layers'' with three nodes each, and there are two commodities. The capacity for each commodity and edge is 0 with a probability of 5\% and otherwise drawn from a uniform distribution between 5 and 15, while the common capacity of the edge e is 0 with probability 25\% and otherwise a number drawn from the uniform distribution. A multi-commodity flow problem is naturally block-structured with a block for each commodity, but it contains usually many global constraints. Therefore, instead of using these blocks to decompose the system, we divide the graph into smaller subgraphs. Similarly to Table~\ref{tab:projections}, Table~\ref{tab:multicom} shows the size of the original model and the projections resulting from a flat and decomposed projection, respectively. Figure~\ref{fig:multicom} shows the progression over time of the number of inequalities and number of variables left to be projected, for both the flat and decomposed projection algorithm.
\begin{table}[t!]
\caption{Size of projection of a multi-commodity flow model.}
\label{tab:multicom}
\centering
\btablesize
\begin{tabular}{l|r@{ / }r@{ / }r@{ / }r|r}
&\multicolumn{4}{c|}{Size}&\multicolumn{1}{c}{Time}\\
											&ineq (eq)&var &nzs &dens&\\
\hline
Original							&204 (42) & 120& 444&2.17&\multicolumn{1}{c}{-}\\
Presolved							& 59		  &  79& 201&3.41&\multicolumn{1}{c}{-}\\
Projected, decomposed	& 17 (2)  &  12&  61&3.59& 2h \phantom{9}9m \\
Projected, flat				& 17 (2)  &  12&  53&3.12& 17h 41m\\
\end{tabular}
\etablesize
\end{table}
Also here we see a reduction in the number of inequalities, variables and non-zero entries, of 3.5, 6.6, and 3.3/3.8 times, respectively (in both cases) compared to the presolved model. The density stays almost the same; for the decomposed model, the density increases with 5.3 \%, while the density decreases with 8.5\% for the flat projection. This is not as large a reduction as for the VSMs, however, the unprojected models are also smaller to begin with. 
\begin{figure}[b!]
	\centering
		\includegraphics{figures/newMultiComGraph.pdf}
	\caption{Inequalities and variables during projection of a multi-commodity flow problem.}
	\label{fig:multicom}
\end{figure}

\section{Related Work} \label{sec:relatedwork}
Other FME-based frameworks for projection includes \cite{simon05,lukatskii08,shapot12}. Similar to our framework, these use simplifications, redundancy removal and approximation-procedures. The latter uses the extreme-point method of \cite{huynh92}, while the boundary-approximation of \cite{lukatskii08,shapot12} involves a successive increase of the allowable deviation from the feasible area and a permissible maximal ratio of removed non-redundant inequalities. Seen from the perspective of capacity models, both frameworks are used on quite small systems. Furthermore, the systems in \cite{simon} are also sparse. Our FME-based framework is to our knowledge the first that can take advantage of block-angular structure in the system. Other methods exist for computing the projection of a feasible area of an (in)equality system, that are not based on FME. The method in \cite{huynh92} finds extreme points in the projection space incrementally. It can therefore also be used to approximate the projection as is done in \cite{simon05}. It is recommended for dense systems. Another example is the method introduced in \cite{jones04}, which computes all facets of the projection iteratively using a face-lattice. This method is recommended by the authors for polytopes with a low facet count and a high vertex count.


\section{Conclusion}\label{sec:conclusion}
This paper has introduced a novel FME projection framework that automatically translates a linear stowage model (VSM) into a smaller sized capacity model (VCM) by projecting unneeded variables. To our knowledge, our framework is the first to exploit block-angular structure and apply massive parallelization of computations. Our results show that the projected VCMs are reduced by an order of magnitude both in number of inequalities and number of non-zero entries. The VCMs including hydrostatic constraints are solved 20-35 times faster than their corresponding VSMs. Similar results are achieved for at multi-commodity flow problem. Future work includes further parallelization and approaches to automatically estimates the best way of decomposing a given system as well as testing the framework on other block-angular problems.

\subsection*{Acknowledgements}
\small We would like to thank Stefan R{\o}pke, Thomas Stidsen, and David Pisinger for discussions on applications of the FME framework beyond container vessel capacity models. This research is supported by the Danish Maritime Fund, Grant No. 2016-064.

\bibliographystyle{abbrv}
\bibliography{bibfile}
\end{document}
